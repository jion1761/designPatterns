# 创建型模型
### 创建模式通过已某种方式控制对象的创建来解决问题
### 两种思想
    1.将系统使用的具体类封装起来
    2.隐藏这些具体类的实例创建和结合的方式  
## 注要包括
    工厂模式
    抽象工厂模式
    单例模式
    建造者模式
    原型模式
   
## 1.简单工厂模式

### 1.1 基本思想
    1.提供了专门的工厂类创建对象
    2.客户端不需知道创建类的名称及创建过程，只需要知道对应产品的参数及相应功能
### 1.2 缺点
    1.创建核心集中在工厂类，如果工厂类出现问题，会造成系统崩溃
    2.类数量过多，增加复杂度
    3.不方便扩展（增加新产品时），不利于维护
### 示例
    public class SimplePizzaFactory {
    
        public Pizza create(String pizzaType){
            Pizza pizza = null;
            if ("Vege".equals(pizzaType)){
                pizza = new VegePizza();
            }
            if ("Meat".equals(pizzaType)){
                pizza = new MeatPizza();
            }
            return pizza;
        }
    }

## 2.工厂模式

### 基本定义
    工厂方法模式定义了一个创建对象的接口，但由子类决定实例化的类是哪个，工厂方法模式让实例化推迟到子类
    (建造模式中的两种分类里面的类创建型)
### 与简单工厂模式区别
    工厂模式是面向接口编程的
### 优点
    在新增产品时，只需新增一个产品类对应实现工厂，无需修改原工厂，很好符合“开闭原则”
**开闭原则：对扩展开放，对修改关闭！方便扩展，易于维护和升级**
### 缺点
    每增加一个产品，都需要增加具体实现工厂的类，增加系统复杂度！
### 使用场景
    如果需要创建多钟对象的时候，同时这些对象又有极大相似点！
    eg:java.util.Calendar#getInstance()
       java.util.ResourceBundle#getBundle()
       java.text.NumberFormat#forName()
## 3.抽象工厂模式

### 基本定义
    抽象工厂模式提供一个接口，用于创建相关或者依赖对象的家族，不需确定具体类 
### 与工厂模式区别
    1.工厂模式产品种类单一，如果有多个种类（产品族），各种类型(某一产品的各种类型)，通过抽象工厂模式创建更合适
    2.抽象工厂模式更多的是扩展我们产品的等级结构
### 使用场景
    1.属于一个产品族的产品将在一起使用
    2.系统提供一个产品类的库，所有产品以同样接口出现，从而使客户端不依赖于具体实现
    
## 4.单例模式
### 基本定义
    1 只有一个实例
    2 必须做到自行实例化
    3 必须自行想整个系统提供访问点
    